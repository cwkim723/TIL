### **#1.5 Why not JavaScript**

**타입스크립트 존재 이유**

-   **타입 안정성**
    -   버그가 줄어듦
    -   런타임에러가 줄어듦
    -   생산성이 늘어남  
    


**자바스크립트 단점**

![[Pasted image 20220817130853.png]]

1.  배열이 사라짐 → 그냥 스트링으로 바뀜
2.  false(boolean) → 스트링으로 변함

⇒ 자바스크립트는 이런 일을 허용하게 됨.  

<br/>


![[Pasted image 20220817130908.png]]

1.  입력값이 두개인데 하나만 보냈음에도 불구하고 코드가 실행됨 → 에러를 표시하는 것이 맞음
2.  자바스크립트는 a와 b가 필수값인지 선택값인지 전혀 알지 못함
3.  a가 숫자여야만 한다고 설명하고 있지 않음

<br/><br/>

**런타임 에러**

-   콘솔 안에서 일어나는 에러
-   코드가 실행될 때만 일어나는 에러
		![[Pasted image 20220817130939.png]]



-   nico 객체에서 hello() 함수를 불러 옴
-   자바스크립트는 이 코드가 에러를 불러 일으킬 줄 모르고 실행시킴 → **실행이 되고 나서야 에러가 일어남**
-   ⇒ 이상적으로 코드 실행 전에 nico 객체에 hello()가 없다는 걸 알려주는 것이 좋음

<br/><br/><br/>

### #2.0 How Typescript Works

-   이상적으로 코드 실행 전에 nico 객체에 hello()가 없다는 걸 알려주는 것이 좋음
    -   ⇒ 타입스크립트

<br/>

**타입스크립트**

-   strongly typed(강타입) 프로그래밍 언어
-   컴파일러를 통해 타입스크립트 코드가 자바스크립트로 변환됨
    -   브라우저가 타입스크립트가 아닌 자바스크립트를 이해하기 때문
    -   Node.js는 타입스크립트, 자바스크립트 둘 다 이해 가능
-   멍청한 실수로부터 개발자를 보호해줌
    -   어떻게 보호해주는 걸까??
-   컴파일러 발생 전에 타입스크립트가 우리의 코드를 확인해줌(런타임 전에 수행)
    -   타입스크립트에 에러가 있으면 자바스크립트로 컴파일해주지 않음
    -   타입스크립트 코드가 자바스크립트로 변환되면 문제가 없다는 의미





<br/>

```jsx
// 자바스크립트
const nico = {
	nickname: "nick"
}
```

<br/>

**에러1**

![[Pasted image 20220817131604.png]]

---

**에러2**

![[Pasted image 20220817131619.png]]

---

**에러3**

![[Pasted image 20220817131635.png]]

1.  a, b는 숫자여야 한다
2.  입력값은 두개여야 한다

---

**에러4**

![[Pasted image 20220817131650.png]]

1.  숫자에서 boolean으로 타입을 바꿀 수 없다

<br/>
<br/>
<br/>

### #2.1 Implicit Types vs Explicit Types

-   1이 들어있는 변수를 만들 때
    -   그 변수가 number라는 것을 정해주어야 함
    -   그 변수가 항상 number라는 걸 컴파일러에게 알려주어야 함

**타입스크립트**

-   type checker가 타입을 확인해줌

1.  **데이터와 변수의 타입을 명시적으로 정의 가능 ⇒ 최소한으로 하는게 좋음**
    
	![[Pasted image 20220817131732.png]]
    
    -   에러 → b는 boolean이어야 하는데 string값을 입력


	    ![[Pasted image 20220817131754.png]]
    
	    -   성공!
    
    ![[Pasted image 20220817131817.png]]
    
    -   값이 비어있을 때는 명시해주는게 좋다



    ![[Pasted image 20220817131850.png]]
    
    -   에러 → player 객체 안에 hello()가 없음을 알려줌

<br/>

2.  **자바스크립트처럼 변수만 선언해주면 타입 추론을 해줌 ⇒ 추천**
    
    ![[Pasted image 20220817132020.png]]
    
    -   ok → a가 String이기 때문
    
	   ![[Pasted image 20220817132037.png]]
    
    -   에러 → a는 string이어야 함
    
    ![[Pasted image 20220817132101.png]]
    
    -   에러 → c 배열에는 숫자만 들어가야 함

<br/><br/><br/>

### #2.2 Types of TS part One

```tsx
let a : number = 1;
let b : String = "i1";
let c : boolean[] = [true]

let a = 1;
let b = "i1";
let c = [true]
```

-   타입스크립트가 타입 추론을 하도록 두는 것이 좋음
-   기본형 타입(basic type)

<br/>

**optional type**

```tsx
const player = {
		name:"nico"
}
player.name // 오류발생!
```

![[Pasted image 20220817132137.png]]

-   player가 있고 player 중 몇몇은 age가 있고 몇몇은 age가 없지만 모두 name을 가지고 있다고 가정(모든 player가 name은 있지만 몇몇만 age를 가짐)
    
-   이를 어떻게 typescript로 해줘야 할까
    
    -   player를 object로 선언 → 소용 없음
        -   object 타입에는 name요소가 없다고 나옴
    
    ```tsx
    const player : {
    		name:string,
    		age?: number
    } = {
    		name:"nico",
    		// age는 optional
    }
    
    if(player.age && player.age < 10) {
    		// age가 null이 아님을 먼저 조건으로 내세워야 함
    }
    ```
    
    -   optional인 경우 **?**를 붙여주면 된다 <br/><br/>
-   만들 때마다 똑같은 구조 반복 → 비효율적
    

```tsx
const playerNico : {
		name: string,
		age?: number
} = {
		name: "nico"
}
```

```tsx
const playerLynn : {
		name: string,
		age?: number
} = {
		name: "lynn",
		age: 12
}
```

-   해결방법
    
    ```tsx
    /* type Player = {
    		name: string,
    		age?: number
    } */
    
    type Age = number;
    type Name = string;
    type Player = {
    		name: Name,
    		age?: Age
    } // alias
    
    const nico : **Player** = {
    		name: "nico"
    }
    
    const lynn : **Player** = {
    		name: "lynn",
    		age: 12
    }
    ```
    
    -   alias를 만들어 준다 (type ~)
        -   별칭 첫 글자는 **대문자**
        -   내 코드가 많은 타입을 재사용할 수 있게 해줌 <br/><br/>
-   함수가 return하는 타입이 뭔지 알 수 있으면 훨씬 안전하게 코드 짜기 가능
    
    -   player() → 함수는 player의 object를 만들고 그 결과로 player를 반환
    
    ```tsx
    type Age = number;
    type Name = string;
    type Player = {
    		name: Name,
    		age?: Age
    } // alias
    
    function playerMaker(name:string) **: Player** {
    		return {
    				name // 원래는 name:name인데 변수명과 값이 같을 때는 하나만 적어줘도 됨
    		}
    }
    
    const nico = playerMaker("nico")
    nico.age = 12 // **: Player** 를 해주지 않으면 에러 발생
    ```
    
    -   타입스크립트에게 playerMaker는 Player 타입을 return하고 있다고 말해주고 싶음
        -   인수들 뒤에 **`: 반환값(콜론 타입) `** <br/><br/>
-   화살표 함수를 썼을 때 playerMaker의 타입을 어떻게 지정하는가
    
    ```tsx
    type Age = number;
    type Name = string;
    type Player = {
    		name: Name,
    		age?: Age
    } // alias
    
    const playerMaker = (name:string) **: Player** => ({name})
    const nico = playerMaker("nico")
    nico.age = 12 // **: Player** 를 해주지 않으면 에러 발생
    ```
    

<br/><br/><br/>

### #2.3 Types of TS part Two

-   원한다면 readonly 속성을 타입에 추가 가능 → 읽기 전용 (자바스크립트에는 x, 타입스크립트에만 존재)

```tsx
type Age = number;
type Name = string;
type Player = {
		**readonly** name: Name,
		age?: Age
} // alias

const playerMaker = (name:string) **: Player** => ({name})
const nico = playerMaker("nico")
nico.age = 12 // **: Player** 를 해주지 않으면 에러 발생
nico.name = "las" // 에러 발생 -> readonly 설정했기 때문
```

-   name을 readonly로 만들고 싶음
    -   → 해당하는 값 앞에 `readonly` 적어주면 됨 <br/><br/>

**readonly**

```tsx
const numbers: **readonly** number[] = [1, 2, 3, 4]
numbers.push(1) // 에러 발생

const numbers: number[] = [1, 2, 3, 4]
numbers.push(1) // 정상 작동

const names: **readonly** string[] = ["1", "2"] // immutability
```

-   **자바스크립트에는 readonly가 작동하지 않음**
    -   타입스크립트에서만 가능 <br/><br/>

**tuple**: array 생성(최소한의 길이, 특정 위치에 특정 타입)

```tsx
["nico", 12, false] // string, number, boolean

// typescript ver
const player: **[string, number, boolean]** = ["nico", 12, true] // 값을 넣어야하지만 에러가 생기지 않음

player[0] = 1 // 에러 -> player[0]는 string이기 때문

// tuple + readonly
const player: **readonly** [string, number, boolean] = ["nico", 12, true]
player[0] = "hi" // 에러 발생 -> readonly 설정
```

-   **자바스크립트에는 tuple이 없음**
    -   타입스크립트에서만 가능 <br/><br/>

**undefined / null**

```tsx
let a : undefined = undefined
let b : null = null

type Player = {
		age**?** : number // **age는 number 혹은 undefined**
}
```

-   **`?`** : 해당타입 혹은 undefined라는 의미 <br/><br/>

**any**

```tsx
let a = [] // -> **let a: any[]** 라고 인식

const a : any[] = [1, 2, 3, 4]
const b : any = true

a + b // 정상
```

-   비어있는 값을 쓰면 기본 값이 any
-   any: 타입스크립트를 빠져나오고 싶을 때 사용
    -   any는 타입스크립트의 모든 보호장치를 비활성화 시킴

<br/><br/><br/>

### #2.4 Types of TS part Three

-   자바스크립트에는 없고 타입스크립트에만 있는 type ⇒ **type checker과 호환 O**
    -   void never unknown

**unknown**

-   api response를 받는데 response의 타입을 모를 경우 unknown이라고 쓸 수 있음

```tsx
let a : unknown

let b = a + 1 // error
if(typeof a === 'number') {
		let b = a + 1 // 정상 -> a가 number임을 확인했기 때문
}

a.toUpperCase // error
if(typeof a === "string") {
		let b = a.toUpperCase(); // 정상 -> a가 string임을 확인
}
```

<br/>

**void**

```tsx
function hello() {
		console.log('x')
}

const a = hello();
a.toUpperCase(); // error -> hello()는 void이기 때문
```

-   hello()는 void
    -   void를 써주지 않아도 void임을 알 수 있음(type checker)

<br/>

**never**

```tsx
function hello(): never {
		throw new Error("xxx");
}
```

1.  에러를 던질 때 return 값을 never로 지정
    
    -   에러를 던지지 않을 때 return 값을 never로 지정하면 에러 발생
2.  never는 타입이 두 가지 일 수도 있는 상황에 발생
    
    ```tsx
    function hello(name:string|number):never {
    		// name + 1 // 에러
    		if(typeof name === "string") {
    				name
    		} else if (typeof name === "number") {
    				name
    		} else {
    				name // never -> name의 타입은 string or number 이므로 이 부분은 절대 실행 안됨
    		}
    }
    ```
    

