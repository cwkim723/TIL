## 11강) 코틀린에서 접근 제어를 다루는 방법

- 자바: public, protected, default, private
1. 자바와 코틀린의 가시성 제어
    
    **자바**
    
    | public | 모든 곳에서 접근 가능 |
    | --- | --- |
    | protected | 같은 패키지 또는 하위 클래스에서만 접근 가능 |
    | default | 같은 패키지에서만 접근 가능 |
    | private | 선언된 클래스내에서만 접근 가능 |
    - 자바의 기본 접근 지시어는 **default**
    
    **코틀린**
    
    | public | 모든 곳에서 접근 가능 |
    | --- | --- |
    | protected | 선언된 클래스 또는 하위 클래스에서만 접근 가능 |
    | internal | 같은 모듈에서만 접근 가능 |
    | private | 선언된 클래스 내에서만 접근 가능 |
    - 코틀린에서 패키지는 namespace를 관리하기 위한 용도로만 사용, 가시성 제어(소통 가능 범위)에는 사용 X
    - 모듈: 한 번에 컴파일되는 코틀린 코드
        - 하위 모듈에 있는 것들을 상위 모듈에서 호출 불가
    - 코틀린의 기본 접근 지시어는 **public**
    
2. 코틀린 파일의 접근 제어
    - 코틀린은 .kt 파일에 변수, 함수, 클래스 여러 개를 만들 수 있음
        
        ```kotlin
        val a = 3
        
        fun add(a: Int, b: Int): Int {
        	return a + b
        }
        
        class Cat()
        ```
        
        | public | 기본값, 어디서든 접근 가능 |
        | --- | --- |
        | protected | 파일(최상단)에는 사용 불가 |
        | internal | 같은 모듈에서만 접근 가능 |
        | private | 같은 파일 내에서만 접근 가능 |
3. 다양한 구성요소의 접근 제어
    
    **클래스 안의 멤버**
    
    | public | 모든 곳에서 접근 가능 |
    | --- | --- |
    | protected | 선언된 클래스 또는 하위 클래스에서만 접근 가능 |
    | internal | 같은 모듈에서만 접근 가능 |
    | private | 선언된 클래스 내에서만 접근 가능 |
    
    **생성자**
    
    - 클래스와 가시성 범위 동일
    
    ```kotlin
    class Bus internal constructor (
    	val price: Int
    )
    ```
    
    - 생성자에 접근 지시어 붙이려면 **constructor** 사용
    
    **유틸성 코드**
    
    - 자바
        
        ```java
        public abstract class StringUtils {
        	private StringUtils() {}
        
        	public boolean isDirectoryPath(String path) {
        		return path.endsWith("/");
        	}
        }
        ```
        
        - 자바에서 유틸성 코드 생성 시 abstract class + private constructor를 사용해 인스턴스화 막음
        
    - 코틀린
        
        ```kotlin
        fun isDirectory(path: String): Boolean {
        	return path.endsWith("/")
        }
        ```
        
    
    **프로퍼티**
    
    - 가시성 동일
    - 프로퍼티의 가시성을 제어하는 법
        
        ```kotlin
        class Car(
        	internal val name: String,
        	_price: Int
        ) {
        	
        	var price = _price
        		private set
        
        }
        ```
        
        1. getter, setter 한 번에 접근 지시어 지정
            
            ```kotlin
            class Car(
            	**internal** val name: String,
            	_price: Int
            )
            ```
            
        2. setter에만 추가로 가시성 부여 가능
            
            ```kotlin
            {
            	var price = _price
            		**private** set
            }
            ```
            
    
4. 자바와 코틀린을 함께 사용할 경우 주의할 점
    - `Internal`은 바이트 코드 상 `public`이 됨 → 자바 코드에서는 코틀린 모듈의 `Internal` 코드를 가져올 수 있음
    - 코틀린의 `protected`와 자바의 `protected`는 다름
        - 자바는 같은 패키지의 코틀린 `protected` 멤버에 접근 가능


## 12강) 코틀린에서 object 키워드를 다루는 방법

1. static 함수와 변수
    
    **자바**
    
    ```java
    public class JavaPerson {
    	private static final int MIN_AGE = 1;
    
    	public static JavaPerson newBaby(String name) {
    		return new JavaPerson(name, MIN_AGE);
    	}
    
    	private String name;
    
    	private int age;
    	
    	private JavaPerson(String name, int age) {
    		this.name = name;
    		this.age = age;
    	}
    }
    ```
    
    **코틀린**
    
    ```kotlin
    class Person private constructor (
    	var name: String,
    	var age: Int,
    ) {
    	
    	companion object {
    //  	private	val MIN_AGE = 1 // 런타임 시 변수 할당
    		private **const** val MIN_AGE = 1 // 컴파일 시 변수 할당
    		fun newBaby(name: String): Person {
    			return Person(name, MIN_AGE)
    		}
    	}
    
    }
    ```
    
    ```java
    public static void main(String[] args) {
    	Person.Companion.newBaby("ABC");
    }
    // companion이라는 이름을 통해서 newBaby에 접근
    ```
    
    - 코틀린은 static이 없고 대신 `companion object`
    - `static`: 클래스가 인스턴스화 될 때 새로운 값이 복제되는게 아니라 정적으로 인스턴스끼리 값을 공유
    - `companion object`
        - 클래스와 동행하는 유일한 오브젝트
        - 동반객체도 하나의 객체로 간주 → 이름을 붙일 수도, interface 구현도 가능
            
            ```kotlin
            class Person private constructor (
            	var name: String,
            	var age: Int,
            ) {
            	
            	companion object Factory : Log {
            		private **const** val MIN_AGE = 1
            
            		@JvmStatic
            		fun newBaby(name: String): Person {
            			return Person(name, MIN_AGE)
            		}
            	}
            
            	override fun log() {
            		println("나는 Person 클래스의 동행객체 Factory예요")
            	}
            
            }
            ```
            
            ```kotlin
            interface Log {
            	fun log()
            }
            ```
            
            ```java
            public static void main(String[] args) {
            	Person.Factory.newBaby("ABC");
            	Person.newBaby("ABC"); // @JvmStatic를 통해 자바에서 static field, static 함수를 쓰는 것처럼 바로 접근 가능
            }
            ```
            
            - `@JvmStatic`를 통해 자바에서 static field, static 함수를 쓰는 것처럼 바로 접근 가능
            - 자바에서 코틀린 companion object를 사용하려면 `@JvmStatic`을 붙여야 함
        - `companion object`에 유틸성 함수를 넣어도 되지만, 최상단 파일을 활용하는 것을 추천
    - `const` : 컴파일 시 변수 할당, 진짜 상수에 붙이기 위한 용도, 기본 타입과 String에 붙일 수 있음
    
2. 싱글톤
- 싱글톤: 단 하나의 인스턴스만을 갖는 클래스
    
    **자바**
    
    ```java
    public class JavaSingleton {
    	private static final JavaSingleton INSTANCE = new JavaSingleton();
    
    	private JavaSingleton() {}
    
    	public static JavaSingleton getInstance() {
    		return INSTANCE;
    	}
    }
    ```
    

**코틀린**

```kotlin
object Singleton
```

```kotlin
object Singleton {
	var a: Int 0
}
```

1. 익명 클래스
    - 익명 클래스: 특정 인터페이스나 클래스를 상속받은 구현체를 일회성으로 사용할 때 쓰는 클래스
    
    **자바**
    
    ```java
    public static void main(String[] args) {
    	moveSomething(**new Movable()** {
    		@Override
    		public void move() {
    			System.out.println("무브무브");
    		}
    
    		@Override
    		public void fly() {
    			System.out.println("플라이플라이");
    		}
    	});
    }
    
    private static void moveSomething(Movable movable) {
    	movable.move();
    	movable.fly();
    }
    ```
    
    - `new 타입이름()`
    
    **코틀린**
    
    ```kotlin
    fun main() {
    	moveSomething(**object: Movable** {
    		override fun move() {
    			println("무브무브")
    		}
    
    		override fun fly() {
    			println("플라이플라이")
    		}
    	})
    }
    
    private fun moveSomething(movable: Movable) {
    	movable.move()
    	movable.fly()
    }
    ```
    
    - `object: 타입이름`


## **13강) 코틀린에서 중첩 클래스를 다루는 방법**

- 계층관계를 나타내거나 논리적인 구조를 표현할 때 중첩 클래스 사용
1. 중첩 클래스의 종류
    
    **자바**
    
    - static을 사용하는 중첩 클래스: 클래스 안에 static을 붙인 클래스, 밖의 클래스 직접 참조 불가
        
        ```java
        public class JavaHouse {
        	private String address;
        	private LivingRoom livingRoom;
        
        	public JavaHouse(String address) {
        		this.address = address;
        		this.livingRoom = new LivingRoom(10);
        	}
        
        	public LivingRoom getLivingRoom() {
        		return livingRoom;
        	}
        
        	public static class LivingRoom {
        		private double area;
        
        		public LivingRoom(double area) {
        			this.area = area;
        		}
        
        		public String getAddress() {
        			return JavaHouse.this.address; // 사용 불가 -> static 사용 클래스기 때문
        		}
        	}
        
        }
        ```
        
    - static을 사용하지 않는 중첩 클래스
        - 내부 클래스 : 밖의 클래스 직접 참조 가능
            
            ```java
            public class JavaHouse {
            	private String address;
            	private LivingRoom livingRoom;
            
            	public JavaHouse(String address) {
            		this.address = address;
            		this.livingRoom = new LivingRoom(10);
            	}
            
            	public LivingRoom getLivingRoom() {
            		return livingRoom;
            	}
            
            	public class LivingRoom {
            		private double area;
            
            		public LivingRoom(double area) {
            			this.area = area;
            		}
            
            		public String getAddress() {
            			return JavaHouse.this.address; // 바깥 클래스와 연결 (static 사용하지 않는 클래스기 때문)
            		}
            	}
            
            }
            ```
            
            - 내부 클래스의 문제점
                - 내부 클래스는 숨겨진 외부 클래스 정보를 가지고 있어 참조를 해지하지 못하는 경우 메모리 누수 발생 가능, 디버깅 어려움
                - 내부 클래스의 직렬화 형태가 명확하게 정의되지 않아 직렬화에 있어 제한
                - ⇒ 클래스 안에 클래스를 만들 때 **static 클래스**를 사용해라
        - 지역 클래스 : 메소드 내부에 클래스 정의
        - 익명 클래스 : 일회성 클래스
    
2. 코틀린의 중첩 클래스와 내부 클래스
    - static 중첩 클래스(권장되는 클래스 안의 클래스)
    - 내부 클래스(권장되지 않는 클래스 안의 클래스)
        **코틀린**
        - 바깥 클래스 참조: `this@바깥클래스`
        - 기본적으로 바깥 클래스 참조하지 않음
            - 바깥 클래스를 참조하고 싶다면 `inner` 키워드 추가
            
        
**자바**

| 클래스 안의 static 클래스 | 바깥 클래스 참조 없음. 권장되는 유형 |
| --- | --- |
| 클래스 안의 클래스 | 바깥 클래스 참조 있음 |

**코틀린**

| 클래스 안의 클래스 | 바깥 클래스 참조 없음. 권장되는 유형 |
| --- | --- |
| 클래스 안의 inner 클래스 | 바깥 클래스 참조 있음 |
        

