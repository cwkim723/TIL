애플리케이션

- 수많은 컴포넌트로 구성
    - 각 컴포넌트는 다른 애플리케이션 구성요소와 협력하여 작업
- 애플리케이션 실행 시 각 컴포넌트가 어떻게 생성되어야 하는지 알 수 있어야 함

<br>

스프링 애플리케이션 컨텍스트(Spring application context)

- 애플리케이션 컴포넌트들을 생성하고 관리하는 컨테이너
    - 애플리케이션 컴포넌트 = 빈(bean): 스프링 애플리케이션 컨텍스트 내부에서 서로 연결되어 완전한 애플리케이션 생성
    
<br>
    
**의존성 주입**

- 빈의 상호 연결은 의존성 주입을 기반으로 수행
- 애플리케이션 컴포넌트에서 의존하는 다른 빈의 생성과 관리를 별도의 개체(컨테이너)가 대신 해줌
- 이 개체에서 모든 컴포넌트를 생성, 관리하고 해당 컴포넌트를 필요로 하는 빈에 주입(연결)
    - 생성자 인자 또는 속성의 접근자 메서드를 통해 처리
- ex. 애플리케이션의 여러 컴포넌트(빈) 중에 재고 수준을 알아내는 재고 서비스, 제품 정보를 제공하는 제품 서비스 컴포넌트


![image](https://user-images.githubusercontent.com/93105083/182273153-e15a327f-8d50-46ff-8673-3a612cca5ab4.png)
    
    
    - 제품 서비스는 재고 서비스에 의존
    - 애플리케이션 컴포넌트는 스프링 애플리케이션 컨텍스트에 의해 관리되고 상호 주입

<br>

**configuration**

- 최신 스프링에서는 자바 기반의 구성(configuration)을 통해 컴포넌트 및 다른 컴포넌트와의 관계를 나타냄
- 과거에는 XML 파일을 통해 나타내곤 함

```java
@Configuration
public class ServiceConfiguration {

	@Bean
	public InventoryService inventoryService() {
		return new InventoryService();
	}

	@Bean
	public ProductService productService() {
		return new ProductService(inventoryService());
	}

}
```

- `@Configuration`
    - 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 **구성 클래스**임을 스프링에게 알려줌
        - 구성 클래스의 메서드에 `@Bean` 애노테이션 지정
            - 각 메서드에 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가되어야 함(각 빈의 ID가 해당 빈을 정의하는 메서드의 이름과 동일)
- XML 기반 구성에 비해 더 강화된 타입 안전과 향상된 리팩토링 기능 제공
- 스프링에는 자동으로 컴포넌트 구성할 수 있는 자동-구성 기능 존재
    - → 별도의 XML 구성 혹은 자바 구성 없어도 됨
        - ⇒ 자동-구성을 할 수 없을 경우에만 필요

<br>

**자동-구성**

- 자동 연결, 컴포넌트 검색 기반
- 컴포넌트 검색을 사용해 스프링은 자동으로 애플리케이션의 classpath에 지정된 컴포넌트를 찾은 후 스프링 애플리케이션 컨텍스트의 빈으로 생성 가능
- 스프링은 자동 연결을 사용하여 의존 관계가 있는 컴포넌트를 자동으로 다른 빈에 주입(연결)

<br>

**스프링 부트 스타터**

- Spring, Web, Thymeleaf, Test 의존성 항목 → <artifactId>에 start 단어 포함 ⇒ 스프링 부트 스타터 의존성
    - 자체적으로 라이브러리 코드를 갖지 않고 다른 라이브러리의 것을 사용
- 스타터 의존성 장점
    1. 모든 라이브러리의 의존성 선언 필요 X → 빌드 파일이 훨씬 더 작아지고 관리 쉬움
    2. 라이브러리 이름이 아닌 기능의 관점으로 의존성 생각(라이브러리 일일이 지정할 필요 없이 웹 스타터 의존성만 추가하면 됨)
    3. 라이브러리 버전 걱정 X → 버전 호환 보장

<br>
  
**애플리케이션 부트스트랩(구동)**

```java
@SpringBootApplication
public class TacoCloudApplication {
	public static void main(String[] args) {
		SpringApplication.run(TacoCloudApplication.class, args);
	}
}
```

- `@SpringBootApplication`
    - 이 코드가 스프링 부트 애플리케이션임을 나타냄
    - 세 개의 애노테이션 결합
        - `@SpringBootConfiguration`
            - 현재 클래스(TacoCloudApplication)를 구성 클래스로 지정
            - `@Configuration`이 특화된 형태
        - `@EnableAutoConfiguration`
            - 스프링 부트 자동 - 구성 활성화
        - `@ComponentScan`
            - 컴포넌트 검색 활성화
            - `@Component`, `@Controller`, `@Service`등의 애노테이션과 함께 클래스 선언
                - → 스프링이 자동으로 이 클래스들을 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트로 등록
- main()
    - JAR 파일 실행 시 호출되어 실행되는 메서드
    - 실제로 애플리케이션 시작, 스프링 애플리케이션 컨텍스트 생성하는 SpringApplication 클래스의 run() 호출
        - run()에 전달되는 매개변수: 구성 클래스, 명령행

<br>
  
**애플리케이션 테스트**

```java
@SpringBootTest
class TacoCloudApplicationTest {

	@Test
	void contextLoads() {
	}

}
```

- `@SpringBootTest`
    - 테스트를 시작하라는 것을 JUnit에 알려줌
- contextLoads()
    - `@SpringBootTest`가 테스트의 스프링 애플리케이션 컨텍스트를 로드한다 하더라도 테스트 메서드가 없으면 아무 일도 하지 않음
    - 실행코드는 없더라도 테스트 메서드가 있는 경우 `@SpringBootTest`가 작업을 수행하게 됨
